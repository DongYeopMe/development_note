# TCP/IP 송·수신구조

## 네크워크 전체 흐름
![KakaoTalk_20231220_102813428_01](https://github.com/mo2-Study-Group/StudyGroup/assets/70151275/89a98c7d-688d-4d76-bfc7-6ab21370c4dc)


PC가 → L2액세스 스위치 → 라우터 → 인터넷 → 라우터 → L2액세스 스위치 → 서버(네이버)

네이버에서 파일 하나를 다운로드 받는다는 상황에

다운로드라는것은 네이버 입장에선 File을 송신(보내는)하는 것이고, PC 입장에선 수신 하는것이다.

중요한건 인터넷 구간에서 정보가 유통 될땐 Packet으로 주고 받는다.

만약 File이 1.4MB 정도라면, Packet은 MTU가 1.4xKB 이다. 약 1024배 정도 차이가 난다.

그러면 1000개 이상 Packet으로 보내야한다.

파일을 송수신하는것은 PC나 서버에서 작동하는 Process가 파일을 송수신하는것이다.

파일을 TCP/IP로 보낸다고 가정하면 TCP라는 것은 연결 지향형 프로토콜,

연결한다는 것은 일종의 통화 연결과 유사합니다. 

→ 연결을 한다음 송수신이 이루어진다.

### 송신
![KakaoTalk_20231220_102813428_02](https://github.com/mo2-Study-Group/StudyGroup/assets/70151275/6133558c-63da-4161-beca-c41f5d839e3d)


송수신이 잘 된다고 가정하고

그림에서 오른쪽은 서버, 왼쪽은 PC라고  가정하면

Process 밑에 TCP 프로그램을 추상화한 파일형태의 인터페이스인 소켓이 있다.

서버쪽 HDD/SDD 라는 보조 기억 장치가 있을거고, 파일이 저장되어 있다.

이 파일이 1.4MB라고 가정 했을때,

여것 중요한건 소켓의 본질이 파일이라고 했는데, 이소켓에 대고 I/O가 일어 날것이다.

I/O(송수신)이 일어날때 소켓에 메모리공간(Buffer)가 있을것이다. 버퍼가 있으면 Buffered I/O가 일어 나고, Buffer가 없고 I/O를 직접 하면 Non-Buffered I/O를 하게 된다.

Procees 안에도 버퍼가 있으며, 이 버퍼의 크기는 Process에서 지정 및 관리합니다.

흘러가는 흐름은

1.4MB 파일을 보낼때 프로세스가 관리하는 버퍼 크기는 프로세스에서 정하기 때문에 전부다 올릴수도 있고, 나눠서 올릴수도 있다. 저 그림은 일부분을 나눠서 올리는 경우이다.

프로세스 버퍼에 올릴때와 프로세스 버퍼에서 소켓 버퍼로 올릴때, Copy가 되면서 메모리에 담는다. 이때 Send라고 명칭을 하며,

이 데이터들을 socket I/O에서 TCP 즉, Usermode→ Kunel mode로 넘어 올때 분해가 일어난다.

 참고로 Usermode 에선 단위가 Stream이다.

이 스트림은 파일 전체를 읽어서 보내야 없어진다.

TCP stack을 만나  Segmentation이 일어나는데 나눈 데이터 한 조각을 넘버링 해서 segment로 만든다. 그다음 IP로 내려와 Packet으로 만들고 보내고, 

받아서 프레임으로 만들어서 보낸다.

<aside>
💡 참고로 Packet엔 IP,프로토콜,소스주소,데이터 등등 다 있습니다.

</aside>

송신 쪽은 Encapsulation이 일어나고, 수신은 Decapsulation이 일어난다.

### 수신
![KakaoTalk_20231220_102813428_02](https://github.com/mo2-Study-Group/StudyGroup/assets/70151275/c6887969-f2fc-4e0b-90d8-e75ecfe7916e)


수신쪽은 프레임이 목적지 까지 오면 송신의 반대로 일어난다.

이 프레임 안에 패킷을 IP까지 타고 올라와서 Decapsulation을 하면, 패킷에서 segment를 꺼내 TCP계층까지 올라간다. 그 데이터 한조각(세그먼트 한 조각)을 소켓 I/O 버퍼에 올리고, 그다음 프로세스(크롬) 버퍼에 올린다.

수신쪽 소켓 I/O 버퍼엔 여유 공간(window size)가 있는데, 송수신 하면서 여유 공간이 줄어 들고, 프로세스 버퍼에 올리면 여유 공간이 늘어 난다.

## 네트워크 장애

네트워크가 불안정해서 장애가 발생하는데,

### Loss

네트워크에서 데이터 패킷이 목적지에 도달하지 못하고, 사라지는 현상.

- 네트워크 혼잡, 부적절한 라우팅, 하드웨어 장애, 신호 감쇠 등 여러 이유로 인해 발생할 수 있다.
- 패킷 손실이 발생하면 데이터 전송의 완전성과 효율성이 저하되며 이는 네트워크 성능 저하로 이어질 수 있다.

상황 예시 : 회사의 화상 회의 시스템 중 회사의 네트워크가 혼잡하거나 회의 시스템을 호스팅하는 서버에 문제가 있을 경우

화상 회의 중에 패킷이 손실될 수 있다. 이로 인해 참가자들은 화면이 멈추거나 소리가 끊기는 등의 현상을 접할 수 있다.

**해결책**

1. **재전송 타임아웃 (Retransmission Timeout, RTO)**
    - TCP는 각 패킷에 대해 타임 아웃을 설정한다.
    - 만약 설정된 시간 내에 해당 패킷에 대한 ACK가 도착안하면 TCP는 해당 패킷이 손실 된걸로 간주하고 재전송한다.
    - RTO는 네트워크 지연시간과 변동성을 고려하여 동적으로 조정된다.
2. **순차 번호 및 확인 응답**
    - TCP는 모든 패킷에 순차 번호를 부여한다.
    - 수신측은 받은 패킷의 순차 번호에 따라 ACK를 송신자에게 보내어 어떤 패킷을 받았는지 알린다.(ACK)
    - 송신 측에서 해당 ACK를 못받으면 재전송한다.
3. **빠른 재전송 (Fast Retransmit)**
    - 송신자가 동일한 순차 번호의 ACK를 연속적으로 여러 번 받으면, 이는 네트워크상에서 패킷 손실이 발생했음을 나타낸다.
    - 예를 들어, 네 개의 패킷을 받아야 하는 client측에서 두 개까지의 패킷만 받은 경우,
    
    →마지막으로 받은 패킷의 번호 ACK를 반복 전송하여 세 번째 패킷이 도착하지 않음을 알리는 것이다. 이런 경우, TCP는 타임아웃을 기다리지 않고 즉시 해당 패킷을 재전송한다.
    

이런 해결책이 있기때문에 TCP는 네트워크에서 패킷 손실이 발생할 경우 이를 효과적으로 처리하고, 데이터 전송의 신뢰성을 유지한다.

그런데 이런 시스템이 있기때문에 밑에 있는 현상들이 나오는거 같습니다.

### Re-Transmission

네트워크 통신 관정에서 동일한 데이터 패킷이 여러 번 수신 되는 현상.

- 이는 네트워크 지연, 패킷 손실 후 재전송 과정, 네트워크 장비 오류로 발생할수 있다.
- TCP 프로토콜은 패킷의 순차 번호를 사용하여 중복된 데이터를 식별하고, 필요하지 않은 중복 패킷을 제거함으로써 데이터 전송의 정확성을 보장한다.

→ ACk #3이 송신측에서 받아야하는데 못받았을때 다시 1,2번 데이터 조각 보내는 현상.

상황 예시 : 파일을 전송하는데, 통신에서 중복 데이터가 발생하는 상황

서버에서 파일 데이터를 패킷으로 나누어 클라이언트에 전송하는데, 네트워크상 일시적인 문제로 특정 패킷을 받앗다는 ACK를 서버에 제대로 전송 못했을때, 서버는 해당 패킷을 손상 됐다고 판단 하고 재전송 한다.

이 과정에서 클라이언트는 같은 내용의 데이터를 2번 받는다. TCP의 순차 번호를 통해 클라이언트는 이러한 중복된 패킷을 식별하고 처리하여, 최종 사용자에게 중복 없는 정확한 이메일 내용을 전달할 수 있다.

## Out of order

**TCP 네트워크 통신에서 발생하는 현상으로, 패킷이 송신된 순서와 다른 순서로 수신되는것을 말한다. ex) 1→2→3→4 정상, 1→ 3→4**

- 네트워크 지연,경로 변경(end point),혼잡등으로 발생 할수 있다.
- TCP는 순서 번호를 이용해 각 패킷의 순서를 추적하며, 수신된 패킷이 올바른 순서가 아닐 경우 재정렬해서 데이터를 올바르게 재조립한다.

상황 예시 : 사용자가 웹사이트에 접속하여 큰 이미지 파일을 다운로드하는 상황

파일은 여러 개의 TCP 패킷으로 나누어져 전송된다. 네트워크 상의 지연이나 혼잡으로 인해, 이 패킷들이 전송된 순서와 다른 순서로 사용자에게 도착할 수 있다.

 즉, 파일의 마지막 부분이 먼저 도착하고 그 다음에 첫 번째 부분이 도착하는 것과 같은 상황이 발생할 수 있다.

이 경우 TCP 프로토콜은 순서 번호를 기반으로 패킷을 올바른 순서대로 재정렬한다. 

만약 어떤 패킷이 누락되었다면, TCP는 해당 패킷을 재전송 요청을 하여 파일이 올바르게 조립되도록 한다.

### **zero window**

**TCP 연결에서 발생하는 현상, 수신측 버퍼가 여유공간이 없어 더이상 데이터를 받을 수 없을때 발생하는 현상.→ 네트워크 송수신 속도가 프로세스가 비워내는 처리속도보다 빠른 경우에 발생한다.**

- 발생 시 송신 측에서 수신측에 알리기 위해 TCP 헤더에 있는 window size 필드를 통해 이 정보를 전달하고, 크기가 0이 되면, 데이터 전송을 중지한다.
- 수신측에서 여유가 생기면 윈도우 업데이트 패킷을 송신측에 보내 데이터 전송을 재개한다.

 상황 예시 : 한 온라인 쇼핑몰에서 대규모 세일 이벤트가 진행할 수천 명의 사용자들이 거의 동시에 해당 웹사이트에 접속하여 구매를 시도할 때, 요청의 양이 너무 많아 서버의 버퍼가 급격히 차기 시작한다.

 서버는 클라이언트에게 윈도우 크기가 0인, 즉 '제로 윈도우' 상태를 알리는 TCP 패킷을 보내고, 이 상태가 되면 클라이언트는 데이터 전송을 중단하고, 서버가 처리할 수 있는 여유가 생길 때까지 기다린다.

결재 버튼 눌럿는데 zero window 발생, 결제가 완료 될때까지 페이지 대기. 서버에서 클라이언트에게 윈도우 크기 업데이트 해서 데이터 전송을 재개 할수있음을 알리게 된다.

# 참고

https://velog.io/@hyungzin0309/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9E%A5%EC%95%A0-%EC%A2%85%EB%A5%98
